---
// src/pages/snake/index.astro
import MainLayout from '../../layouts/MainLayout.astro';
---

<MainLayout title="Snake Game — Supm3n">

  <!-- GAME HTML STRUCTURE -->
  <main id="main-content" class="container snake-page">
    <section class="game-header">
      <h1>Snake Game</h1>
      <p>Use arrow keys, WASD, or click/tap to change direction</p>
    </section>

    <div class="game-container">
      <div class="game-info">
        <div class="score-display">
          <div class="score-item">
            <span class="score-label">Score</span>
            <span class="score-value" id="score">0</span>
          </div>
          <div class="score-item">
            <span class="score-label">High Score</span>
            <span class="score-value" id="high-score">0</span>
          </div>
        </div>
        <div class="game-controls">
          <button id="start-btn" class="btn btn-primary">Start</button>
          <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button>
          <button id="reset-btn" class="btn btn-secondary">Reset</button>
        </div>
      </div>

      <div class="game-wrapper">
        <canvas id="game-canvas"></canvas>
        
        <!-- Overlays -->
        <div id="game-over" class="game-over hidden">
          <h2>Game Over!</h2>
          <p class="final-score">Final Score: <span id="final-score">0</span></p>
          <button id="play-again-btn" class="btn btn-primary">Play Again</button>
        </div>
        
        <div id="game-start" class="game-start">
          <h2>Snake Game</h2>
          <p>Click Start to begin</p>
        </div>
      </div>

      <div class="controls-info">
        <div class="control-section">
          <h3>Keyboard Controls</h3>
          <div class="control-grid">
            <div class="control-item">
              <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd>
              <span>Arrow Keys</span>
            </div>
            <div class="control-item">
              <kbd>W</kbd> <kbd>S</kbd> <kbd>A</kbd> <kbd>D</kbd>
              <span>WASD</span>
            </div>
            <div class="control-item">
              <kbd>Space</kbd>
              <span>Pause/Resume</span>
            </div>
          </div>
        </div>
        <div class="control-section">
          <h3>Mouse/Touch Controls</h3>
          <p>Click or tap on the game area to change direction</p>
          <p class="hint">Click above snake = Up, below = Down, left = Left, right = Right</p>
        </div>
      </div>
    </div>
  </main>

</MainLayout>

<!-- STYLES -->
<!-- We use is:global because we need to modify the site-header/footer specifically for this page -->
<style is:global>
  /* ---------------------------------------------------------
     1. HEADER & FOOTER OVERRIDES (From your old index.html)
     --------------------------------------------------------- */
  :root {
    --snake-header-height: 72px;
  }

  /* Force header to be sticky and solid for the game */
  body .site-header {
    position: sticky !important;
    top: 0 !important;
    z-index: 100 !important;
    background: var(--glass-bg, rgba(15, 17, 20, 0.8)) !important;
    backdrop-filter: blur(12px) saturate(180%) !important;
    border-bottom: 1px solid var(--glass-border) !important;
  }

  /* Hide Footer on mobile to maximize game space */
  @media (max-width: 768px), (max-height: 900px) {
    body footer.site-footer {
      display: none !important;
    }
  }

  /* Compact footer on desktop */
  body footer.site-footer {
    margin-top: 0.25rem !important;
    padding: 0.5rem 0 !important;
    min-height: auto !important;
    background: transparent !important;
    border-top: 1px solid var(--glass-border) !important;
  }

  /* ---------------------------------------------------------
     2. GAME SPECIFIC STYLES (From your old styles.css)
     --------------------------------------------------------- */
  
  /* Layout Fixes */
  .snake-page {
    flex: 1;
    display: flex;
    flex-direction: column;
    width: 100%;
    justify-content: center;
    min-height: 0;
  }

  .game-header {
    text-align: center;
    margin: 1rem 0;
    flex-shrink: 0;
  }

  .game-header h1 {
    font-size: clamp(1.5rem, 4vw, 2rem);
    margin-bottom: 0.25rem;
    background: linear-gradient(135deg, var(--color-accent-start), var(--color-accent-end));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .game-header p {
    color: var(--color-text-muted);
    font-size: clamp(0.875rem, 2vw, 1rem);
    margin: 0;
  }

  .game-container {
    max-width: 520px;
    margin: 0 auto;
    width: 100%;
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    justify-content: center;
  }

  /* Score Board */
  .game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--color-surface-2);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
  }

  .score-display {
    display: flex;
    gap: 1rem;
  }

  .score-item {
    display: flex;
    flex-direction: column;
  }

  .score-label {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
  }

  .score-value {
    font-size: 1.5rem;
    font-weight: 700;
    font-family: var(--font-mono);
    color: var(--color-accent-end);
  }

  .game-controls {
    display: flex;
    gap: 0.5rem;
  }

  /* Buttons */
  .btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }

  .btn-primary {
    background: linear-gradient(135deg, var(--color-accent-start), var(--color-accent-end));
    color: white;
  }
  .btn-secondary {
    background: var(--color-surface-1);
    color: var(--color-text-primary);
    border: 1px solid var(--glass-border);
  }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .btn:hover:not(:disabled) { transform: translateY(-2px); }

  /* Canvas Wrapper */
  .game-wrapper {
    position: relative;
    background: var(--color-surface-2);
    border: 2px solid var(--glass-border);
    border-radius: 12px;
    padding: 0.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 1rem;
  }

  #game-canvas {
    display: block;
    border-radius: 8px;
    background: var(--color-base);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    max-width: 100%;
    height: auto;
  }

  /* Overlays (Game Over / Start) */
  .game-over, .game-start {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--color-surface-1);
    border: 2px solid var(--glass-border);
    border-radius: 12px;
    padding: 2rem;
    text-align: center;
    z-index: 10;
    backdrop-filter: blur(12px);
  }
  .hidden { display: none; }
  
  .game-over h2, .game-start h2 { font-size: 1.5rem; margin-bottom: 1rem; }
  .final-score { font-size: 1.2rem; color: var(--color-text-muted); margin-bottom: 1.5rem; }
  .final-score span { color: var(--color-accent-end); font-weight: 700; }

  /* Controls Info (Desktop Only) */
  .controls-info {
    display: none;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  @media (min-height: 900px) and (min-width: 768px) {
    .controls-info { display: grid; }
  }

  .control-item {
    display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem;
    background: var(--color-surface-2); border-radius: 8px; margin-bottom: 0.5rem;
  }
  
  kbd {
    background: var(--color-base); border: 1px solid var(--glass-border);
    border-radius: 4px; padding: 2px 6px; font-family: monospace;
  }

  /* Mobile Adjustments */
  @media (max-width: 768px) {
    .game-header p { display: none; }
    .game-info { flex-direction: row; flex-wrap: wrap; }
    .controls-info { display: none; }
  }
</style>

<!-- GAME LOGIC -->
<script>
class SnakeGame {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    if (!this.canvas) return; // Safety check

    this.ctx = this.canvas.getContext('2d');
    this.gridSize = 20;
    this.tileCount = 20;
    
    this.setCanvasSize();
    window.addEventListener('resize', () => this.setCanvasSize());
    
    this.snake = [{ x: 10, y: 10 }];
    this.food = { x: 15, y: 15 };
    this.dx = 0;
    this.dy = 0;
    this.score = 0;
    this.highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');
    this.gameRunning = false;
    this.gamePaused = false;
    this.gameLoop = null;
    this.nextDirection = null;
    
    this.init();
  }
  
  setCanvasSize() {
    const isMobile = window.innerWidth <= 768;
    const isShortScreen = window.innerHeight <= 800;
    
    // Calculate responsive size
    const padding = isMobile ? 20 : 40;
    const headerFooterSpace = isMobile || isShortScreen ? 160 : 280;
    
    const maxWidth = Math.min(400, window.innerWidth - padding);
    const availableHeight = window.innerHeight - headerFooterSpace;
    const maxHeight = Math.min(400, availableHeight);
    
    const size = Math.min(maxWidth, maxHeight);
    const canvasSize = Math.floor(size / this.tileCount) * this.tileCount;
    const finalSize = Math.max(canvasSize, this.tileCount * 10);
    
    this.canvas.width = finalSize;
    this.canvas.height = finalSize;
    this.canvas.style.width = finalSize + 'px';
    this.canvas.style.height = finalSize + 'px';
    
    this.gridSize = finalSize / this.tileCount;
    
    if (this.snake) this.draw();
  }
  
  init() {
    this.updateHighScore();
    this.setupEventListeners();
    this.draw();
  }
  
  setupEventListeners() {
    document.addEventListener('keydown', (e) => this.handleKeyPress(e));
    
    this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));
    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.handleMouseClick(e.touches[0]);
    });
    
    document.getElementById('start-btn').addEventListener('click', () => this.start());
    document.getElementById('pause-btn').addEventListener('click', () => this.togglePause());
    document.getElementById('reset-btn').addEventListener('click', () => this.reset());
    document.getElementById('play-again-btn').addEventListener('click', () => {
      document.getElementById('game-over').classList.add('hidden');
      this.reset();
      this.start();
    });
  }
  
  handleKeyPress(e) {
    if (!this.gameRunning && e.key !== ' ') return;
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
      e.preventDefault();
    }
    
    if (e.key === ' ') {
      this.togglePause();
      return;
    }
    
    const key = e.key.toLowerCase();
    let newDx = this.dx;
    let newDy = this.dy;
    
    if (key === 'arrowup' || key === 'w') {
      if (this.dy === 0) { newDx = 0; newDy = -1; }
    } else if (key === 'arrowdown' || key === 's') {
      if (this.dy === 0) { newDx = 0; newDy = 1; }
    } else if (key === 'arrowleft' || key === 'a') {
      if (this.dx === 0) { newDx = -1; newDy = 0; }
    } else if (key === 'arrowright' || key === 'd') {
      if (this.dx === 0) { newDx = 1; newDy = 0; }
    }
    
    if (this.gameRunning && !this.gamePaused) {
      this.nextDirection = { dx: newDx, dy: newDy };
    } else if (!this.gameRunning) {
      this.dx = newDx;
      this.dy = newDy;
    }
  }
  
  handleMouseClick(e) {
    if (!this.gameRunning || this.gamePaused) return;
    
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const head = this.snake[0];
    const headX = head.x * this.gridSize + this.gridSize / 2;
    const headY = head.y * this.gridSize + this.gridSize / 2;
    
    const dx = x - headX;
    const dy = y - headY;
    
    let newDx = this.dx;
    let newDy = this.dy;
    
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0 && this.dx === 0) { newDx = 1; newDy = 0; }
      else if (dx < 0 && this.dx === 0) { newDx = -1; newDy = 0; }
    } else {
      if (dy > 0 && this.dy === 0) { newDx = 0; newDy = 1; }
      else if (dy < 0 && this.dy === 0) { newDx = 0; newDy = -1; }
    }
    
    this.nextDirection = { dx: newDx, dy: newDy };
  }
  
  start() {
    if (this.gameRunning) return;
    this.gameRunning = true;
    this.gamePaused = false;
    document.getElementById('game-start').classList.add('hidden');
    document.getElementById('game-over').classList.add('hidden');
    document.getElementById('start-btn').disabled = true;
    document.getElementById('pause-btn').disabled = false;
    
    if (this.dx === 0 && this.dy === 0) {
      this.dx = 1; this.dy = 0;
    }
    
    this.gameLoop = setInterval(() => this.update(), 150);
  }
  
  togglePause() {
    if (!this.gameRunning) return;
    this.gamePaused = !this.gamePaused;
    const pauseBtn = document.getElementById('pause-btn');
    
    if (this.gamePaused) {
      clearInterval(this.gameLoop);
      pauseBtn.textContent = 'Resume';
    } else {
      this.gameLoop = setInterval(() => this.update(), 150);
      pauseBtn.textContent = 'Pause';
    }
  }
  
  reset() {
    this.gameRunning = false;
    this.gamePaused = false;
    this.snake = [{ x: 10, y: 10 }];
    this.food = this.generateFood();
    this.dx = 0; this.dy = 0;
    this.score = 0;
    this.nextDirection = null;
    
    if (this.gameLoop) { clearInterval(this.gameLoop); this.gameLoop = null; }
    
    document.getElementById('start-btn').disabled = false;
    document.getElementById('pause-btn').disabled = true;
    document.getElementById('pause-btn').textContent = 'Pause';
    document.getElementById('game-start').classList.remove('hidden');
    
    this.updateScore();
    this.draw();
  }
  
  update() {
    if (this.gamePaused) return;
    
    if (this.nextDirection) {
      this.dx = this.nextDirection.dx;
      this.dy = this.nextDirection.dy;
      this.nextDirection = null;
    }
    
    const head = { x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy };
    
    // Wall collision
    if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
      this.gameOver(); return;
    }
    
    // Self collision
    if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      this.gameOver(); return;
    }
    
    this.snake.unshift(head);
    
    // Food collision
    if (head.x === this.food.x && head.y === this.food.y) {
      this.score += 10;
      this.updateScore();
      this.food = this.generateFood();
      while (this.snake.some(segment => segment.x === this.food.x && segment.y === this.food.y)) {
        this.food = this.generateFood();
      }
    } else {
      this.snake.pop();
    }
    
    this.draw();
  }
  
  generateFood() {
    return {
      x: Math.floor(Math.random() * this.tileCount),
      y: Math.floor(Math.random() * this.tileCount)
    };
  }
  
  draw() {
    this.ctx.fillStyle = '#0B0C10';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Grid
    this.ctx.strokeStyle = '#151820';
    this.ctx.lineWidth = 1;
    for (let i = 0; i <= this.tileCount; i++) {
      this.ctx.beginPath();
      this.ctx.moveTo(i * this.gridSize, 0);
      this.ctx.lineTo(i * this.gridSize, this.canvas.height);
      this.ctx.stroke();
      
      this.ctx.beginPath();
      this.ctx.moveTo(0, i * this.gridSize);
      this.ctx.lineTo(this.canvas.width, i * this.gridSize);
      this.ctx.stroke();
    }
    
    // Snake
    this.snake.forEach((segment, index) => {
      if (index === 0) this.ctx.fillStyle = '#06B6D4';
      else {
        const alpha = 1 - (index / this.snake.length) * 0.5;
        this.ctx.fillStyle = `rgba(6, 182, 212, ${alpha})`;
      }
      this.ctx.fillRect(
        segment.x * this.gridSize + 1,
        segment.y * this.gridSize + 1,
        this.gridSize - 2,
        this.gridSize - 2
      );
    });
    
    // Food
    this.ctx.fillStyle = '#EF4444';
    this.ctx.beginPath();
    this.ctx.arc(
      this.food.x * this.gridSize + this.gridSize / 2,
      this.food.y * this.gridSize + this.gridSize / 2,
      this.gridSize / 2 - 2,
      0,
      Math.PI * 2
    );
    this.ctx.fill();
  }
  
  gameOver() {
    this.gameRunning = false;
    clearInterval(this.gameLoop);
    
    if (this.score > this.highScore) {
      this.highScore = this.score;
      localStorage.setItem('snakeHighScore', this.highScore.toString());
      this.updateHighScore();
    }
    
    document.getElementById('final-score').textContent = this.score;
    document.getElementById('game-over').classList.remove('hidden');
    document.getElementById('start-btn').disabled = false;
    document.getElementById('pause-btn').disabled = true;
  }
  
  updateScore() { document.getElementById('score').textContent = this.score; }
  updateHighScore() { document.getElementById('high-score').textContent = this.highScore; }
}

// Start game when component loads
new SnakeGame();
</script>