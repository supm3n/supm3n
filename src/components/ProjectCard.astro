---
const { project } = Astro.props;
---

<article class="project-card reveal">
    <a
        href={project.url}
        class="project-card-link"
        aria-label={`Open ${project.name}`}
    >
        <div class="project-card-header">
            <div class="project-icon-wrapper">
                {
                    project.icon.includes(".") ? (
                        <img
                            class="project-icon"
                            src={project.icon}
                            alt={project.name}
                        />
                    ) : (
                        <div class="project-icon-emoji">{project.icon}</div>
                    )
                }
            </div>

            <div class="project-info">
                <h3 class="project-title">{project.name}</h3>
                <p class="project-description">{project.description}</p>
            </div>
        </div>
        <div class="project-meta">
            <span class="project-tag">{project.tag}</span>
            <span class="project-link">
                Open
                <svg
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    width="16"
                    height="16"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                    ></path>
                </svg>
            </span>
        </div>
    </a>
</article>

<style>
    .project-card {
        position: relative;
        border-radius: 20px;
        background: var(--color-surface-2);
        border: 1px solid var(--glass-border);
        overflow: hidden;
        transition: all 0.3s ease;
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    /* Magnetic Effect Styles */
    .project-card[data-magnetic-active] {
        will-change: transform;
        transition:
            box-shadow 0.3s,
            border-color 0.3s;
    }

    .project-card:not([data-magnetic-active]):hover {
        transform: translateY(-8px);
    }

    .project-card:hover {
        box-shadow: 0 16px 48px rgba(124, 58, 237, 0.15);
        border-color: var(--color-accent-start);
    }

    [data-theme="light"] .project-card:hover {
        box-shadow: 0 16px 48px rgba(124, 58, 237, 0.1);
    }

    .project-card-link {
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
        padding: var(--space-lg);
        text-decoration: none;
        color: inherit;
        height: 100%;
        flex: 1;
    }

    .project-card-header {
        display: flex;
        align-items: flex-start;
        gap: var(--space-md);
    }

    .project-icon-wrapper {
        flex-shrink: 0;
    }

    .project-icon {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        object-fit: contain;
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border: 1px solid var(--glass-border);
    }

    .project-icon-emoji {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.05);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        border: 1px solid var(--glass-border);
    }

    [data-theme="light"] .project-icon,
    [data-theme="light"] .project-icon-emoji {
        background: rgba(0, 0, 0, 0.03);
    }

    .project-info {
        display: flex;
        flex-direction: column;
    }

    .project-title {
        font-size: var(--text-lg);
        font-weight: 700;
        margin-bottom: var(--space-xs);
        color: var(--color-text-primary);
        margin-top: 0;
        line-height: 1.2;
    }

    .project-description {
        font-size: var(--text-sm);
        color: var(--color-text-muted);
        line-height: 1.5;
        margin: 0;
    }

    .project-meta {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        margin-top: auto;
        padding-top: var(--space-md);
        border-top: 1px solid var(--glass-border);
    }

    .project-tag {
        padding: 4px 10px;
        border-radius: 6px;
        font-size: var(--text-xs);
        font-weight: 600;
        background: var(--color-surface-1);
        color: var(--color-text-muted);
        border: 1px solid var(--glass-border);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .project-link {
        margin-left: auto;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: var(--text-sm);
        font-weight: 600;
        color: var(--color-accent-start);
        padding: 6px 12px;
        border-radius: 8px;
        background: rgba(124, 58, 237, 0.08);
        transition: background 0.2s;
    }

    .project-card:hover .project-link {
        background: rgba(124, 58, 237, 0.15);
    }

    /* Scroll Reveal */
    .reveal {
        opacity: 0;
        transform: translateY(30px);
        transition:
            opacity 0.6s ease,
            transform 0.6s ease;
    }
    .reveal.visible {
        opacity: 1;
        transform: translateY(0);
    }
</style>

<script>
    // Self-contained magnetic effect for cards
    // We use a weakmap or just a simple check to avoid re-binding if we had client-side routing (Astro is MPA by default but good practice)

    function initMagneticCards() {
        if (window.matchMedia("(prefers-reduced-motion: reduce)").matches)
            return;
        if ("ontouchstart" in window || navigator.maxTouchPoints > 0) return;

        const cards = document.querySelectorAll(".project-card");
        const MAGNETIC_RADIUS = 200;
        const MAX_MOVEMENT = 10; // Reduced movement for subtlety
        const RETURN_SPEED = 0.15;

        cards.forEach((card) => {
            if (card.hasAttribute("data-magnetic-init")) return;
            card.setAttribute("data-magnetic-init", "true");
            card.setAttribute("data-magnetic-active", "true");

            let currentX = 0,
                currentY = 0,
                targetX = 0,
                targetY = 0,
                animationId = null;

            function animate() {
                currentX += (targetX - currentX) * RETURN_SPEED;
                currentY += (targetY - currentY) * RETURN_SPEED;

                if (Math.abs(currentX) > 0.05 || Math.abs(currentY) > 0.05) {
                    card.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                    animationId = requestAnimationFrame(animate);
                } else {
                    card.style.transform = "";
                    animationId = null;
                }
            }

            function onMouseMove(e) {
                const rect = card.getBoundingClientRect();
                const deltaX = e.clientX - (rect.left + rect.width / 2);
                const deltaY = e.clientY - (rect.top + rect.height / 2);
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance < MAGNETIC_RADIUS) {
                    const strength = 1 - distance / MAGNETIC_RADIUS;
                    targetX = (deltaX / distance) * strength * MAX_MOVEMENT;
                    targetY = (deltaY / distance) * strength * MAX_MOVEMENT;
                } else {
                    targetX = 0;
                    targetY = 0;
                }
                if (!animationId) animationId = requestAnimationFrame(animate);
            }

            function onMouseLeave() {
                targetX = 0;
                targetY = 0;
                if (!animationId) animationId = requestAnimationFrame(animate);
            }

            card.addEventListener("mousemove", onMouseMove);
            card.addEventListener("mouseleave", onMouseLeave);
        });
    }

    // Run on load
    initMagneticCards();

    // Reveal animation
    const observer = new IntersectionObserver(
        (entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    entry.target.classList.add("visible");
                    observer.unobserve(entry.target);
                }
            });
        },
        { threshold: 0.1 },
    );

    document.querySelectorAll(".reveal").forEach((el) => observer.observe(el));
</script>
